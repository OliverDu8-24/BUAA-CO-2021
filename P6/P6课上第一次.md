## 一、P6课下：理清了各种条件写的思路

在我看来，条件写是指这样一类指令，该指令有关**写寄存器**的控制信号（如到底**要不要写**：RegWrite，到底**写哪个寄存器**：RegDst）在某些阶段未知，导致暂停和转发出现一些问题。下面先以实例表现一下：

### 1.lhonez

从内存读出**半字**数据，比较该数据中数字1和0的个数的多少，1多的情况下将该数据写入rt寄存器，否则将pc+4写入31号寄存器。（即写入的**寄存器编号**以及**写入的具体值**在**M级**之前不确定）。

### 2.lwso

从内存读出数据，若数据大于0，则将数据写入rt寄存器，否则不写（即**是否写入**在**M级**之前不确定）。

### 3.movz

当GRF[rt] > 0时，将GRF[rs]写入GRF[rd]，否则不写，（这个指令我放在了E级判断，而没有放到D级，因此在我的设计中其是否写入在**E级**之前不确定）

注：在**E级**之前不确定是否要写的指令应该是存在的，本处的movz也许是个不恰当的例子，但大家理解那个意思就行。

看完以上三例，大家是否对条件写有些感觉了呢？

##### 现在我**总结一下：**

所有条件写可能可以分为以下3类（名字是我依据个人理解起的）：

- 条件跳转写入：在D级经CMP产生条件真值后明确了所有信号，无需特殊处理（如b类指令）
- 条件计算写入：在E级经ALU计算产生条件真值，由于E级实质上是**暂停和转发**使用控制信号的第一级，故此时该指令也相当于明确了所有信号（把条件真值**连入E_CU**即可），**无需特殊处理**。
- 条件存储写入：在M级产生真值，那么在**E级**会有两种信号不确定，一种是**RegWrite不确定**，另一种是**RegDst不确定**。此时无论如何，E级的控制信号必定有未知值，因此**必须处理**。

这里对第三类展开讨论：

首先否掉**暴力暂停**。

其次，对于第一种RegWrite不确定，不知道大家怎么实现的，我的暂停逻辑（或者说是AT法）的前提是**a3不等于0**，而a3不等于0的前提是**RegWrite不等于0**，显然对于条件存储的第一类，其在E级的RegWrite为**x**，无法支持正常暂停。因此我**必须**在E级使得该指令的RegWrite**默认为1**。但是经过测试，虽然暂停实现了，但是由于我最开始采用的是**暴力转发**，导致出现一种现象，如：

```verilog
lwso $t1, ($0)
sw $t1, ($0)
```

此时根据AT法再加上我的**默认RegWrite为1**，导致sw接受了错误的转发，（此时根据暴力转发的原理，**先前错误的转发**一定会被**最后一次正确转发**覆盖，这样看来似乎没错），但这时如果到M级发现lwso**根本不写入**，导致最后一次转发**不执行**，这样sw之前的错误转发**没有被覆盖**，那就会得到错误的结果。为了解决这个问题就必须对暴力转发进行改进，我加上了**相应T_new==0**（**如**转发源是DE寄存器，则加上E_Tnew==0）的条件，暂且叫做**谨慎转发**，也就是转发一定发生在转发源计算出正确结果时或之后。（关于谨慎转发是否一定正确还有待讨论，但我认为谨慎转发只是减少了暴力转发中的错误转发，只是变得**保守**了，正确性应该和暴力转发一致）。

经过以上思考，我们就解决了第一类条件存储。（**默认E级RegWrite为1，采用谨慎转发**）

最后，我们来讨论第二种条件存储，该指令的RegWrite是明确的，但是要写的寄存器编号在E级未知，因此（AT法的）暂停逻辑依然无法实现。此时我们必须在E级采用一种**条件暂停**，也就是：E级若是该条指令，并且D级指令**可能**用到E级指令**可能**要写的全部寄存器时，**暂停**。（几个优化：特判零、依旧使用T_use<T_new的条件）可以看出，条件暂停比暴力暂停是一大进步，有了它我们就不怕**TLE**了。

下面我们对上述提到的新名词做个回顾：

**谨慎转发**：只有当产生正确值时再转发，使转发可控

**条件暂停**：识别条件写指令，给予特殊暂停

一点建议：对于第二类条件存储，可能会出现E_a3=xxx，导致表达式为未知值，转发错误，采用**===**更保险。

讨论：在思考上述方法时，我还和同学进行了如下讨论：

M级是否需要参与到**条件判断**中？

我的答案是**不需要**，因为在M级已经可以得到正确控制信号，而越早确定控制信号意味着越有可能**全力转发**。

刘俊辰的答案：**需要**，在M级确定控制信号会增加关键路径，在实际电路中不可取，而且抢那几个周期也没必要。

## 二、P6课上：我的思路

### 1.shl

交换HI、LO寄存器的值，实现起来非常简单，我用了**7分钟**写完，交上去看到大概有**60多人**排队，可见此题的目的是为了强测大家的课下。

### 2.jap

难度升级。指令码为前六位110110，后26位为立即数，类似j指令。

该指令有三个操作，还涉及一个栈的模型。

**文字描述**如下：

- 从编号为**29号**的寄存器读出数据，作为地址将**pc+8**写入**内存**
- 维护这个以29号寄存器的值为栈顶指针的栈（这个栈和内存里的栈一样是**倒着**长得），即让29号寄存器的值**减4**再写入29号**寄存器**
- 完成与**j指令**一摸一样的跳转操作

**RTL语言描述**如下：

1. addr <- GRF[29]
2. mem[addr] <- pc+8
3. GRF[29]<-GRF[29]-4
4. pc<-pc[31:28]||imm26||00

我的**解题思路**：

- 由于29这一常数作为指令**要读**的寄存器以及指令**要写**的寄存器，却并没有出现在指令码中，也就是我们无法根据指令的**相应字段**来确定指令的行为，所以我们只能强行定义，此处我将jap的**rs段**定义为29。（这一步将成为我们后续实现的基础）

```verilog
rs = (jap) ? 29 : instr[20:16];
```

- 由于在操作中实际用到了两个关于GRF[29]的值，一个是GRF[29]本身，另一个是GRF[29]-4，此时我们有两种选择：在**ALU计算出**GRF[29]-4，另一种是**ALU的结果**仍然是GRF[29]，采用第一个的好处是E_Tnew可以定义为1，采用第二个的好处是直接把ALU_result作为地址传给mem即可。这里我选择了第一种，目的是最后写入寄存器时直接用ALU的result即可，可以少改一个选择器，而且E_Tnew可以定义为1。

以上是我认为的解题重点，解题的具体细节就不展开了。

### 3.lwer:

文字描述如下：

从内存读出数(memword)，经表达式

```
(memword + GRF[rt]) & 0x1e
```

算出**要写的**寄存器编号（必为偶数），再将memword写入该寄存器。

分析：

典型的**第二类条件存储**，根据第一部分的分析，我们可以采用**E级条件暂停、M级正常判断**来实现。

一个注意的点，E级条件暂停的条件应为D级**使用了偶数寄存器**，我是这样写的：E_lwer为代表E级是lwer指令。

```verilog
assign stall_lwer = (E_lwer && ((D_rs[0] == 0 && D_rs && D_rs_Tuse < E_Tnew) || (D_rt[0] == 0 && D_rt && D_rt_Tuse < E_Tnew) ));
```